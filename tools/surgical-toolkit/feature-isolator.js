#!/usr/bin/env node

/**
 * Feature Isolator Tool
 * Creates isolated sandboxes for feature development without affecting main code
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class FeatureIsolator {
  constructor() {
    this.featureFlags = new Map();
    this.isolatedFiles = new Map();
    this.backups = new Map();
  }

  /**
   * Create an isolated feature branch with automatic switching
   */
  async createFeatureIsolation(featureName, files = []) {
    console.log(`\n🔒 Creating isolated environment for feature: ${featureName}\n`);

    const isolation = {
      name: featureName,
      id: `feature-${Date.now()}`,
      timestamp: new Date().toISOString(),
      files: [],
      flags: [],
      proxies: [],
      status: 'ACTIVE'
    };

    try {
      // 1. Create feature flag
      isolation.flags = await this.createFeatureFlag(featureName);

      // 2. Create file proxies
      for (const file of files) {
        const proxy = await this.createFileProxy(file, featureName);
        isolation.proxies.push(proxy);
      }

      // 3. Create isolation wrapper
      const wrapper = await this.createIsolationWrapper(featureName, files);
      isolation.wrapper = wrapper;

      // 4. Setup automatic switching
      await this.setupAutoSwitch(featureName);

      // 5. Create rollback points
      isolation.rollback = await this.createRollbackPoint(featureName, files);

      // 6. Generate isolation config
      await this.saveIsolationConfig(isolation);

      return isolation;
    } catch (error) {
      console.error('Error creating isolation:', error);
      throw error;
    }
  }

  /**
   * Create feature flag configuration
   */
  async createFeatureFlag(featureName) {
    const flagConfig = `
// Feature Flag: ${featureName}
// Auto-generated by Feature Isolator

const FEATURE_FLAGS = {
  ${featureName.toUpperCase()}: {
    enabled: process.env.FEATURE_${featureName.toUpperCase()} === 'true',
    version: '1.0.0',
    description: 'Isolated feature: ${featureName}',
    createdAt: '${new Date().toISOString()}',
    rollout: {
      percentage: 0,
      userGroups: [],
      excludeGroups: []
    }
  }
};

// Feature flag checker
function isFeatureEnabled(feature) {
  const flag = FEATURE_FLAGS[feature];
  if (!flag) return false;

  // Check if explicitly enabled
  if (flag.enabled) return true;

  // Check rollout percentage
  if (flag.rollout.percentage > 0) {
    const hash = hashString(getUserId());
    return (hash % 100) < flag.rollout.percentage;
  }

  return false;
}

// Safe feature wrapper
function withFeature(feature, enabledCallback, disabledCallback = () => {}) {
  if (isFeatureEnabled(feature)) {
    return enabledCallback();
  }
  return disabledCallback();
}

module.exports = { FEATURE_FLAGS, isFeatureEnabled, withFeature };
`;

    const flagPath = `./features/flags/${featureName}.flag.js`;
    await this.ensureDirectory(path.dirname(flagPath));
    await fs.writeFile(flagPath, flagConfig);

    return [{
      name: featureName.toUpperCase(),
      path: flagPath,
      enabled: false
    }];
  }

  /**
   * Create a proxy file that switches between original and feature version
   */
  async createFileProxy(filePath, featureName) {
    const ext = path.extname(filePath);
    const baseName = path.basename(filePath, ext);
    const dirName = path.dirname(filePath);

    // Create feature version path
    const featurePath = path.join(dirName, `${baseName}.${featureName}${ext}`);

    // Copy original to feature version
    try {
      const originalContent = await fs.readFile(filePath, 'utf-8');
      await fs.writeFile(featurePath, originalContent);
    } catch (error) {
      // Original might not exist yet
      await fs.writeFile(featurePath, '// Feature version\n');
    }

    // Create proxy content based on file type
    let proxyContent = '';

    if (ext === '.js' || ext === '.ts') {
      proxyContent = `
// Auto-generated proxy for feature isolation
// Original: ${filePath}
// Feature: ${featurePath}

const { isFeatureEnabled } = require('./features/flags/${featureName}.flag.js');

if (isFeatureEnabled('${featureName.toUpperCase()}')) {
  // Load feature version
  module.exports = require('./${baseName}.${featureName}${ext}');
} else {
  // Load original version
  module.exports = require('./${baseName}.original${ext}');
}
`;
    } else if (ext === '.css') {
      proxyContent = `
/* Auto-generated proxy for feature isolation */
/* Original: ${filePath} */
/* Feature: ${featurePath} */

@import url('./${baseName}.original${ext}');

[data-feature="${featureName}"] {
  @import url('./${baseName}.${featureName}${ext}');
}
`;
    }

    // Backup original
    const backupPath = `${filePath}.original`;
    try {
      await fs.rename(filePath, backupPath);
    } catch (error) {
      // Already backed up
    }

    // Write proxy
    await fs.writeFile(filePath, proxyContent);

    return {
      original: backupPath,
      feature: featurePath,
      proxy: filePath
    };
  }

  /**
   * Create isolation wrapper for runtime switching
   */
  async createIsolationWrapper(featureName, files) {
    const wrapperContent = `
/**
 * Isolation Wrapper for ${featureName}
 * Provides runtime switching between original and feature code
 */

class IsolationWrapper {
  constructor() {
    this.featureName = '${featureName}';
    this.isEnabled = false;
    this.originalCode = new Map();
    this.featureCode = new Map();
  }

  enable() {
    this.isEnabled = true;
    document.body.setAttribute('data-feature', '${featureName}');
    this.switchToFeature();
    console.log('🟢 Feature ${featureName} enabled');
  }

  disable() {
    this.isEnabled = false;
    document.body.removeAttribute('data-feature');
    this.switchToOriginal();
    console.log('🔴 Feature ${featureName} disabled');
  }

  toggle() {
    if (this.isEnabled) {
      this.disable();
    } else {
      this.enable();
    }
  }

  switchToFeature() {
    // Dynamic module replacement for feature code
    ${files.map(file => `
    if (window.requirejs) {
      requirejs.undef('${file}');
      requirejs.config({
        paths: {
          '${file}': '${file}.${featureName}'
        }
      });
    }
    `).join('\n')}
  }

  switchToOriginal() {
    // Dynamic module replacement for original code
    ${files.map(file => `
    if (window.requirejs) {
      requirejs.undef('${file}');
      requirejs.config({
        paths: {
          '${file}': '${file}.original'
        }
      });
    }
    `).join('\n')}
  }

  // A/B testing helper
  enableForPercentage(percentage) {
    const userId = this.getUserId();
    const hash = this.hashCode(userId);
    const bucket = Math.abs(hash) % 100;

    if (bucket < percentage) {
      this.enable();
    } else {
      this.disable();
    }
  }

  getUserId() {
    return localStorage.getItem('userId') || 'anonymous';
  }

  hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }
}

// Create global instance
window.${featureName}Isolation = new IsolationWrapper();

// Add console commands
console.log('🔧 Feature Isolation Commands:');
console.log('  Enable:  ${featureName}Isolation.enable()');
console.log('  Disable: ${featureName}Isolation.disable()');
console.log('  Toggle:  ${featureName}Isolation.toggle()');
console.log('  A/B Test: ${featureName}Isolation.enableForPercentage(50)');

module.exports = window.${featureName}Isolation;
`;

    const wrapperPath = `./features/wrappers/${featureName}.wrapper.js`;
    await this.ensureDirectory(path.dirname(wrapperPath));
    await fs.writeFile(wrapperPath, wrapperContent);

    return wrapperPath;
  }

  /**
   * Setup automatic switching based on environment
   */
  async setupAutoSwitch(featureName) {
    const switcherContent = `
// Auto-switcher for ${featureName}
// Checks environment and URL params for feature activation

(function() {
  const featureName = '${featureName}';

  // Check URL params
  const urlParams = new URLSearchParams(window.location.search);
  const urlFeature = urlParams.get('feature');

  // Check localStorage
  const localFeature = localStorage.getItem('feature_' + featureName);

  // Check environment variable (for Node.js)
  const envFeature = typeof process !== 'undefined' &&
                     process.env['FEATURE_' + featureName.toUpperCase()];

  // Determine if feature should be enabled
  const shouldEnable = urlFeature === featureName ||
                      localFeature === 'true' ||
                      envFeature === 'true';

  if (shouldEnable && window.${featureName}Isolation) {
    window.${featureName}Isolation.enable();
  }

  // Add keyboard shortcut for toggling (Ctrl+Shift+F)
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'F') {
      if (window.${featureName}Isolation) {
        window.${featureName}Isolation.toggle();
        e.preventDefault();
      }
    }
  });
})();
`;

    const switcherPath = `./features/switchers/${featureName}.switch.js`;
    await this.ensureDirectory(path.dirname(switcherPath));
    await fs.writeFile(switcherPath, switcherContent);

    return switcherPath;
  }

  /**
   * Create rollback point for quick recovery
   */
  async createRollbackPoint(featureName, files) {
    const rollbackData = {
      feature: featureName,
      timestamp: new Date().toISOString(),
      files: [],
      commands: []
    };

    for (const file of files) {
      try {
        const content = await fs.readFile(file, 'utf-8');
        const backup = {
          path: file,
          content: content,
          hash: this.hashContent(content)
        };
        rollbackData.files.push(backup);
      } catch (error) {
        // File might not exist
      }
    }

    // Generate rollback script
    const rollbackScript = `
#!/bin/bash
# Rollback script for ${featureName}
# Generated: ${rollbackData.timestamp}

echo "🔄 Rolling back feature: ${featureName}"

# Restore original files
${rollbackData.files.map(f => `
echo "Restoring ${f.path}"
mv ${f.path}.original ${f.path} 2>/dev/null || true
rm ${f.path}.${featureName}* 2>/dev/null || true
`).join('\n')}

# Remove feature flags
rm -rf ./features/flags/${featureName}.flag.js
rm -rf ./features/wrappers/${featureName}.wrapper.js
rm -rf ./features/switchers/${featureName}.switch.js

echo "✅ Rollback complete"
`;

    const rollbackPath = `./features/rollbacks/${featureName}.rollback.sh`;
    await this.ensureDirectory(path.dirname(rollbackPath));
    await fs.writeFile(rollbackPath, rollbackScript);
    await fs.chmod(rollbackPath, '755');

    rollbackData.script = rollbackPath;
    return rollbackData;
  }

  /**
   * Save isolation configuration
   */
  async saveIsolationConfig(isolation) {
    const configPath = `./features/configs/${isolation.name}.config.json`;
    await this.ensureDirectory(path.dirname(configPath));
    await fs.writeFile(configPath, JSON.stringify(isolation, null, 2));

    console.log('\n✅ Feature Isolation Created Successfully!');
    console.log(`📁 Config saved to: ${configPath}`);
    console.log(`\n🎯 To activate the feature:`);
    console.log(`  • In browser: Add ?feature=${isolation.name} to URL`);
    console.log(`  • In console: ${isolation.name}Isolation.enable()`);
    console.log(`  • In environment: export FEATURE_${isolation.name.toUpperCase()}=true`);
    console.log(`  • Keyboard: Press Ctrl+Shift+F to toggle`);

    return configPath;
  }

  /**
   * List all isolated features
   */
  async listIsolatedFeatures() {
    try {
      const configDir = './features/configs';
      const files = await fs.readdir(configDir);
      const features = [];

      for (const file of files) {
        if (file.endsWith('.config.json')) {
          const content = await fs.readFile(path.join(configDir, file), 'utf-8');
          features.push(JSON.parse(content));
        }
      }

      return features;
    } catch (error) {
      return [];
    }
  }

  /**
   * Helper functions
   */
  async ensureDirectory(dir) {
    try {
      await fs.mkdir(dir, { recursive: true });
    } catch (error) {
      // Directory exists
    }
  }

  hashContent(content) {
    const crypto = require('crypto');
    return crypto.createHash('md5').update(content).digest('hex');
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  const isolator = new FeatureIsolator();

  if (!command || command === 'help') {
    console.log(`
🔐 Feature Isolator Tool

Usage:
  node feature-isolator.js <command> [options]

Commands:
  create <name> <files...>  Create isolated feature environment
  list                      List all isolated features
  rollback <name>          Rollback a feature
  status <name>            Check feature status

Examples:
  node feature-isolator.js create dark-mode src/theme.css src/theme.js
  node feature-isolator.js create new-api src/api/client.js
  node feature-isolator.js list
  node feature-isolator.js rollback dark-mode
    `);
    process.exit(0);
  }

  switch (command) {
    case 'create': {
      const name = args[1];
      const files = args.slice(2);

      if (!name || files.length === 0) {
        console.error('❌ Please provide feature name and files to isolate');
        process.exit(1);
      }

      await isolator.createFeatureIsolation(name, files);
      break;
    }

    case 'list': {
      const features = await isolator.listIsolatedFeatures();

      if (features.length === 0) {
        console.log('No isolated features found');
      } else {
        console.log('\n📦 Isolated Features:\n');
        features.forEach(f => {
          console.log(`  • ${f.name} (${f.status})`);
          console.log(`    Created: ${f.timestamp}`);
          console.log(`    Files: ${f.proxies.length}`);
        });
      }
      break;
    }

    case 'rollback': {
      const name = args[1];
      if (!name) {
        console.error('❌ Please provide feature name to rollback');
        process.exit(1);
      }

      const rollbackPath = `./features/rollbacks/${name}.rollback.sh`;
      execSync(`bash ${rollbackPath}`, { stdio: 'inherit' });
      break;
    }

    case 'status': {
      const name = args[1];
      if (!name) {
        console.error('❌ Please provide feature name');
        process.exit(1);
      }

      try {
        const configPath = `./features/configs/${name}.config.json`;
        const config = JSON.parse(await fs.readFile(configPath, 'utf-8'));
        console.log('\n📊 Feature Status:');
        console.log(JSON.stringify(config, null, 2));
      } catch (error) {
        console.error(`❌ Feature '${name}' not found`);
      }
      break;
    }

    default:
      console.error(`❌ Unknown command: ${command}`);
      process.exit(1);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = FeatureIsolator;