import {onRequest} from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import {initializeApp} from "firebase-admin/app";
import {getFirestore} from "firebase-admin/firestore";
import {getStorage} from "firebase-admin/storage";
import busboy from "busboy";

initializeApp();

export const api = onRequest({
  invoker: "public"
}, async (req, res) => {
  const db = getFirestore();
  const storage = getStorage();
  
  if (req.path === "/health") {
    res.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      version: "2.0.0",
      environment: process.env.NODE_ENV || "production"
    });
    return;
  }
  
  if (req.path === "/upload/file" && req.method === "POST") {
    try {
      const fileData = await handleFileUpload(req, storage);
      const fileRef = db.collection('uploads').doc(fileData.id);
      await fileRef.set({
        ...fileData,
        status: 'uploaded',
        createdAt: new Date()
      });
      
      res.json({
        success: true,
        file: fileData,
        message: 'File uploaded successfully',
        nextSteps: {
          process: `/api/upload/process/${fileData.id}`,
          status: `/api/upload/status/${fileData.id}`
        }
      });
    } catch (error) {
      logger.error("File upload error:", error);
      const errorMessage = error instanceof Error ? error.message : 'File upload processing failed';
      res.status(400).json({
        success: false,
        error: 'Upload failed',
        message: errorMessage,
        accepted: ['PDF', 'CSV', 'XLS', 'XLSX'],
        limits: {
          maxSize: '10MB',
          maxFiles: 1
        }
      });
    }
    return;
  }
  
  if (req.path === "/upload/url" && req.method === "POST") {
    try {
      const body = req.body || {};
      const { url } = body;
      
      if (!url) {
        res.status(400).json({
          success: false,
          error: 'URL required',
          format: { url: 'https://example.com/conference-schedule' }
        });
        return;
      }
      
      try {
        new URL(url);
      } catch {
        res.status(400).json({
          success: false,
          error: 'Invalid URL format',
          format: { url: 'https://example.com/conference-schedule' }
        });
        return;
      }
      
      const urlInfo = {
        id: Date.now().toString(),
        url: url,
        status: 'processing',
        submittedAt: new Date().toISOString(),
        type: 'url_submission'
      };
      
      const urlRef = db.collection('url_submissions').doc(urlInfo.id);
      await urlRef.set({
        ...urlInfo,
        createdAt: new Date()
      });
      
      res.json({
        success: true,
        submission: urlInfo,
        message: 'URL submitted for processing'
      });
    } catch (error) {
      logger.error("URL processing error:", error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to process URL submission';
      res.status(500).json({
        success: false,
        error: 'URL processing failed',
        message: errorMessage
      });
    }
    return;
  }
  
  if (req.path === "/parties/feed") {
    try {
      const partiesRef = db.collection('parties');
      const snapshot = await partiesRef.get();
      
      const parties = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      
      res.json({
        success: true,
        data: parties.length > 0 ? parties : getFallbackParties(),
        meta: {
          count: parties.length || 3,
          loadTime: "45ms",
          swipeSession: `session_${Date.now()}${Math.random()}`,
          filters: {
            hideOld: false,
            limit: 10
          },
          source: parties.length > 0 ? "firestore" : "fallback"
        }
      });
    } catch (error) {
      logger.error("Firestore error:", error);
      res.json({
        success: true,
        data: getFallbackParties(),
        meta: {
          count: 3,
          loadTime: "12ms",
          swipeSession: `session_${Date.now()}${Math.random()}`,
          filters: {
            hideOld: false,
            limit: 10
          },
          source: "fallback"
        }
      });
    }
    return;
  }
  
  res.status(404).json({success: false, error: "Endpoint not found"});
});

async function handleFileUpload(req: any, storage: any): Promise<any> {
  return new Promise((resolve, reject) => {
    const allowedTypes = [
      'application/pdf', 
      'text/csv',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    ];
    
    const maxSize = 10 * 1024 * 1024;
    let fileUploaded = false;
    
    const bb = busboy({ 
      headers: req.headers,
      limits: {
        fileSize: maxSize,
        files: 1
      }
    });
    
    bb.on('file', async (fieldname: string, file: any, info: any) => {
      const { filename, mimeType } = info;
      
      const isValidType = allowedTypes.includes(mimeType) || filename.endsWith('.csv');
      if (!isValidType) {
        reject(new Error(`Invalid file type: ${mimeType}. Accepted: PDF, CSV, XLS, XLSX`));
        return;
      }
      
      try {
        const fileId = `${Date.now()}_${filename}`;
        const bucket = storage.bucket();
        const fileRef = bucket.file(`uploads/${fileId}`);
        
        const chunks: Buffer[] = [];
        let fileSize = 0;
        
        file.on('data', (chunk: Buffer) => {
          fileSize += chunk.length;
          if (fileSize > maxSize) {
            reject(new Error('File size exceeds 10MB limit'));
            return;
          }
          chunks.push(chunk);
        });
        
        file.on('end', async () => {
          try {
            const buffer = Buffer.concat(chunks);
            
            await fileRef.save(buffer, {
              metadata: {
                contentType: mimeType,
                metadata: {
                  originalName: filename,
                  uploadedAt: new Date().toISOString()
                }
              }
            });
            
            const fileInfo = {
              id: fileId,
              originalName: filename,
              mimeType: mimeType,
              size: fileSize,
              path: `uploads/${fileId}`,
              uploadedAt: new Date().toISOString(),
              cloudStoragePath: `gs://${bucket.name}/uploads/${fileId}`
            };
            
            fileUploaded = true;
            resolve(fileInfo);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown upload error';
            reject(new Error(`Cloud Storage upload failed: ${errorMessage}`));
          }
        });
        
        file.on('error', (error: Error) => {
          reject(new Error(`File stream error: ${error.message}`));
        });
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown processing error';
        reject(new Error(`File processing error: ${errorMessage}`));
      }
    });
    
    bb.on('finish', () => {
      if (!fileUploaded) {
        reject(new Error('No file uploaded'));
      }
    });
    
    bb.on('error', (error: Error) => {
      reject(new Error(`Upload parsing error: ${error.message}`));
    });
    
    req.pipe(bb);
  });
}

function getFallbackParties() {
  return [
    {
      id: "party-1",
      name: "Tech Leaders Networking",
      host: "Google Developer Group", 
      time: "2025-08-04T19:00:00Z",
      location: "Rooftop Bar, Hotel Monaco",
      description: "Connect with fellow tech leaders over cocktails",
      attendeeCount: 45,
      image: "/images/party-1.jpg",
      tags: ["networking", "tech", "cocktails"]
    },
    {
      id: "party-2", 
      name: "Designer After Party",
      host: "Design Systems Inc",
      time: "2025-08-04T21:30:00Z",
      location: "Studio 42, Downtown", 
      description: "Celebrate great design with music and drinks",
      attendeeCount: 32,
      image: "/images/party-2.jpg",
      tags: ["design", "music", "creative"]
    },
    {
      id: "party-3",
      name: "Startup Founder Mixer", 
      host: "Venture Capital Collective",
      time: "2025-08-05T18:00:00Z",
      location: "Innovation Hub, Building 7",
      description: "Meet fellow entrepreneurs and potential co-founders", 
      attendeeCount: 28,
      image: "/images/party-3.jpg",
      tags: ["startup", "founders", "networking"]
    }
  ];
}
// Force redeploy to pick up new IAM permissions
